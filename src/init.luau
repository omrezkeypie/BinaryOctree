--!optimize 2
--!native

type Object = {
	Position: Vector3
}

export type BinaryOctree = {
	MaxDepth: number?,
	Size: number,
	OffsetPosition : Vector3?,
	Nodes: {{Object}},
}

type Module = {
	new: (Size: number, MaxDepth: number?,OffsetPosition : Vector3?) -> BinaryOctree,
	InsertObjects: (BinaryOctree: BinaryOctree, Objects: { Object }) -> (),
	QueryBox: (BinaryOctree: BinaryOctree, Position: Vector3, Size: Vector3) -> {Object},
	QuerySphere: (BinaryOctree : BinaryOctree,Position : Vector3,Radius : number) -> {Object},
	RemoveObject: (BinaryOctree : BinaryOctree,Object : Object) -> (),
	InsertObject: (BinaryOctree : BinaryOctree,Object : Object) -> (),
	VisualizeOctree: (BinaryOctree : BinaryOctree) -> ()
}

local SuffixToOrder = {
	Vector3.new(-1,-1,-1),--0
	Vector3.new(-1,-1,1), --1
	Vector3.new(-1,1,-1), --2
	Vector3.new(-1,1,1),  --3
	Vector3.new(1,-1,-1), --4
	Vector3.new(1,-1,1),  --5
	Vector3.new(1,1,-1),  --6
	Vector3.new(1,1,1),   --7
}

local Dot = Vector3.new().Dot
local SubdivideThreshold = 30

local BinaryOctreeModule: Module = {} :: Module

local function IsPositionInBox(Position: Vector3, MinBounds : Vector3, MaxBounds : Vector3) : boolean
	return Position.X >= MinBounds.X and Position.X <= MaxBounds.X
		and Position.Y >= MinBounds.Y and Position.Y <= MaxBounds.Y
		and Position.Z >= MinBounds.Z and Position.Z <= MaxBounds.Z
end

local function DetectBoxOverlap(MinBounds1 : Vector3,MaxBounds1 : Vector3,MinBounds2 : Vector3,MaxBounds2 : Vector3) : boolean	
	return MinBounds1.X < MaxBounds2.X and MaxBounds1.X > MinBounds2.X and 
		MinBounds1.Y < MaxBounds2.Y and MaxBounds1.Y > MinBounds2.Y and 
		MinBounds1.Z < MaxBounds2.Z and MaxBounds1.Z > MinBounds2.Z
end

local function MagnitudeSquared(Position : Vector3) : number
	return (Position.X * Position.X) + (Position.Y * Position.Y)  + (Position.Z * Position.Z)
end

local function DetectBoxAndSphereOverlap(MinBounds : Vector3,MaxBounds : Vector3,SphereCenter : Vector3,RadiusSquared : number) : boolean
	local ClosestPoint = SphereCenter:Max(MinBounds):Min(MaxBounds)
	local Distance = MagnitudeSquared(SphereCenter - ClosestPoint)

	return Distance <= RadiusSquared
end

local function Subdivide(BinaryOctree : BinaryOctree,Node : number)
	local ShiftedNode = Node * 8

	for i = 0,7 do
		BinaryOctree.Nodes[ShiftedNode + i] = {}
	end
end

local function GetNodePositionAndSize(BinaryOctree : BinaryOctree,Node : number) : (Vector3,Vector3)
	local NumberLength = math.max(32-bit32.countlz(Node), 0) - 1
	local Position = Vector3.zero
	local HalfSize = BinaryOctree.Size / 4
	HalfSize = Vector3.new(HalfSize,HalfSize,HalfSize)

	for Index = 1,NumberLength,3 do
		local Suffix = bit32.extract(Node,NumberLength - Index - 2,3)

		Position = Position + (HalfSize * SuffixToOrder[Suffix + 1])

		Index += 3
		HalfSize = HalfSize / 2
	end

	return BinaryOctree.OffsetPosition + Position,HalfSize * 2
end

local function ReassignObjects(BinaryOctree : BinaryOctree,Node : number,NodePosition : Vector3)
	Subdivide(BinaryOctree,Node)

	local NodeTable = BinaryOctree.Nodes[Node]
	local ShiftedNode = Node * 8

	for i = 1,#NodeTable do
		local Object = NodeTable[i]
		local Position = Object.Position
		local Suffix = 0

		if Position.X > NodePosition.X then
			Suffix += 4
		end

		if Position.Y > NodePosition.Y then
			Suffix += 2
		end

		if Position.Z > NodePosition.Z then
			Suffix += 1
		end

		table.insert(BinaryOctree.Nodes[ShiftedNode + Suffix],Object)
	end

	table.clear(NodeTable)
end

function BinaryOctreeModule.new(Size : number,MaxDepth : number?,OffsetPosition : Vector3?) : BinaryOctree
	local newBinaryOctree = {
		MaxDepth = if MaxDepth then math.clamp(MaxDepth,1,10) else 5,
		Size = Size,
		OffsetPosition = if OffsetPosition then OffsetPosition else Vector3.zero,
		Nodes = {{}},
	}

	return newBinaryOctree
end

function BinaryOctreeModule.InsertObjects(BinaryOctree : BinaryOctree,Objects : {Object})
	local QuarterSize = BinaryOctree.Size / 4
	local Size = QuarterSize
	local Depth = 0
	local NodePosition = BinaryOctree.OffsetPosition
	local ChosenNode = 1
	local MaxDepth = BinaryOctree.MaxDepth

	for _,Object in Objects do
		local Position = Object.Position

		while true do
			local Suffix = 0

			if Position.X > NodePosition.X then
				Suffix += 4
			end

			if Position.Y > NodePosition.Y then
				Suffix += 2
			end

			if Position.Z > NodePosition.Z then
				Suffix += 1
			end

			local NextNode = ChosenNode * 8 + Suffix

			if BinaryOctree.Nodes[NextNode] == nil then
				local ChosenNodeTable = BinaryOctree.Nodes[ChosenNode]

				table.insert(ChosenNodeTable,Object)

				if #ChosenNodeTable > SubdivideThreshold and Depth < MaxDepth then
					ReassignObjects(BinaryOctree,ChosenNode,NodePosition)
				end

				break
			end

			NodePosition = NodePosition + (Size * SuffixToOrder[Suffix + 1])

			Size = Size / 2
			ChosenNode = NextNode
			Depth = Depth + 1
		end

		Size = QuarterSize
		Depth = 0
		NodePosition = BinaryOctree.OffsetPosition
		ChosenNode = 1
	end
end

function BinaryOctreeModule.InsertObject(BinaryOctree : BinaryOctree,Object : Object)
	local Size = BinaryOctree.Size / 4
	local Depth = 0
	local NodePosition = BinaryOctree.OffsetPosition
	local ChosenNode = 1
	local MaxDepth = BinaryOctree.MaxDepth
	local Position = Object.Position

	while true do
		local Suffix = 0

		if Position.X > NodePosition.X then
			Suffix += 4
		end

		if Position.Y > NodePosition.Y then
			Suffix += 2
		end

		if Position.Z > NodePosition.Z then
			Suffix += 1
		end

		local NextNode = ChosenNode * 8 + Suffix

		if BinaryOctree.Nodes[NextNode] == nil then
			local ChosenNodeTable = BinaryOctree.Nodes[ChosenNode]

			table.insert(ChosenNodeTable,Object)

			if #ChosenNodeTable > SubdivideThreshold and Depth < MaxDepth then
				ReassignObjects(BinaryOctree,ChosenNode,NodePosition)
			end

			break
		end

		NodePosition = NodePosition + (Size * SuffixToOrder[Suffix + 1])

		Size = Size / 2
		ChosenNode = NextNode
		Depth = Depth + 1
	end
end

function BinaryOctreeModule.RemoveObject(BinaryOctree : BinaryOctree,Object : Object)
	local Size = BinaryOctree.Size / 4
	local ChosenNode = 1
	local NodePosition = BinaryOctree.OffsetPosition
	local Position = Object.Position

	while true do
		local Suffix = 0

		if Position.X > NodePosition.X then
			Suffix += 4
		end

		if Position.Y > NodePosition.Y then
			Suffix += 2
		end

		if Position.Z > NodePosition.Z then
			Suffix += 1
		end

		local NextNode = ChosenNode * 8 + Suffix

		if BinaryOctree.Nodes[NextNode] == nil then
			local LeafNode = BinaryOctree.Nodes[ChosenNode]
			table.remove(LeafNode,table.find(LeafNode,Object))

			break
		end

		NodePosition = NodePosition + (Size * SuffixToOrder[Suffix + 1])
		Size = Size / 2
		ChosenNode = NextNode
	end
end

function BinaryOctreeModule.QueryBox(BinaryOctree : BinaryOctree,Position : Vector3,Size : Vector3) : {Object}
	local MinBound = Position - (Size / 2)
	local MaxBound = Position + (Size / 2)
	local ChosenNodes = {1}
	local Nodes = BinaryOctree.Nodes
	local GottenObjects = {}

	while #ChosenNodes > 0 do
		local Node = table.remove(ChosenNodes)
		local NodeTable = Nodes[Node]
		local NodePosition,NodeSize = GetNodePositionAndSize(BinaryOctree,Node)
		if not DetectBoxOverlap(MinBound,MaxBound,NodePosition - NodeSize,NodePosition + NodeSize) then continue end

		local ShifterNumber = Node * 8

		for HashSuffix = 0,7 do
			local NextNode = ShifterNumber + HashSuffix

			if Nodes[NextNode] == nil then
				if #NodeTable > 0 then
					for _,Object in NodeTable do
						if not IsPositionInBox(Object.Position,MinBound,MaxBound) then continue end

						table.insert(GottenObjects,Object)
					end
				end				

				break
			end

			table.insert(ChosenNodes,NextNode)
		end
	end

	return GottenObjects
end

function BinaryOctreeModule.QuerySphere(BinaryOctree : BinaryOctree,Position : Vector3,Radius : number) : {Object}
	local ChosenNodes = {1}
	local Nodes = BinaryOctree.Nodes
	local GottenObjects = {}
	Radius *= Radius

	while #ChosenNodes > 0 do
		local Node = table.remove(ChosenNodes)
		local NodeTable = Nodes[Node]
		local NodePosition,NodeSize = GetNodePositionAndSize(BinaryOctree,Node)

		if not DetectBoxAndSphereOverlap(NodePosition - NodeSize,NodePosition + NodeSize,Position,Radius) then continue end

		local ShifterNumber = Node * 8

		for HashSuffix = 0,7 do
			local NextNode = ShifterNumber + HashSuffix


			if Nodes[NextNode] == nil then
				if #NodeTable > 0 then
					for _,Object in NodeTable do
						local SubtractedPositions = Position - Object.Position

						if Dot(SubtractedPositions,SubtractedPositions,SubtractedPositions) <= Radius then 
							table.insert(GottenObjects,Object)
						end
					end
				end				

				break
			end

			table.insert(ChosenNodes,NextNode)
		end
	end

	return GottenObjects
end

local function MakeVisualisePart(Size, MaxBound, Suffix)
	local MiddlePosition = MaxBound

	local VisualizePart = Instance.new("Part")
	VisualizePart.Parent = workspace
	VisualizePart.Position = MiddlePosition
	VisualizePart.Size = Vector3.new(Size,Size,Size)
	VisualizePart.Anchored = true
	VisualizePart.Transparency = 1
	VisualizePart.Name = Suffix

	local SelectionBox = Instance.new("SelectionBox")
	SelectionBox.Parent = VisualizePart
	SelectionBox.Adornee = VisualizePart
end

function BinaryOctreeModule.VisualizeOctree(BinaryOctree : BinaryOctree)
	local UnvisualisedNodes = {{1,Size = BinaryOctree.Size}}

	while #UnvisualisedNodes > 0 do
		local Node = table.remove(UnvisualisedNodes)
		local NodePosition = GetNodePositionAndSize(BinaryOctree,Node[1])

		MakeVisualisePart(Node.Size,NodePosition,Node[1])

		for i = 0,7 do
			local HashIndex = Node[1] * 8 + i

			if BinaryOctree.Nodes[HashIndex] == nil then continue end

			table.insert(UnvisualisedNodes,{HashIndex, Size = Node.Size / 2})
		end
	end
end

return BinaryOctreeModule
